#pragma once

/*
	C++ implementation of the multiple-choice knapsack algorithm.
		Attempts to find the combination of options which optimizes value,
		while keeping net burden below a hard limit.

	In typical use-cases, burden is proportional to CPU or GPU time.
		Maximum burden is chosen to maintain a desirable framerate or
		meet a deadline of some other kind (eg, for audio rendering).

	The algorithm is most useful when burden values come from live profiling.
		It's also possible to use estimated proportional burden values,
		dynamically adjusting the maximum burden based on overall performance.
*/

#include <limits>    // std::numeric_limits
#include <algorithm> // std::min, std::max
#include <cassert>
#include <vector>
#include <map>


namespace perf_goblin
{
	/*
		A class encapsulating the problem definition and algorithm for this library.
	*/
	template<typename T_Real>
	struct Problem_
	{
	public:
		static const bool EnableProfiling = true;

		using real_t  = T_Real;
		using index_t = size_t;
		using score_t = ptrdiff_t;

		// A single item that may be chosen.
		struct option_t
		{
			// Burden represents a cost applying to some finite resource.
			//   The algorithm keeps total burden under some maximum.
			//   This value is typically positive (but not required to be).
			real_t burden = real_t(1.0);

			// Value represents the benefit or detriment from picking this option.
			//   The algorithm tries to maximize value.
			//   This value may be positive or negative.
			real_t value  = real_t(1.0);

			// Rounded value used in the algorithm.
			score_t _points;
		};

		// A set of items.
		using options_t = std::vector<option_t>;

		// A choice among some number of items.
		struct decision_t
		{
			options_t options;

			// The current choice among options.
			//    This is overwritten by the algorithm.
			index_t choice = 0;

			// Temporary values set by the algorithm
			real_t _value_min;
			size_t _choice_min;
			size_t _choice_high;
		};

		// Statistics describing a set of decisions.
		struct statistics_t
		{
			real_t  net_burden = 0;
			real_t  net_value  = 0;
			score_t net_points = 0;

			statistics_t &operator+=(const option_t &o)
			{
				net_burden += o.burden;
				net_value  += o.value;
				net_points += o._points;
				return *this;
			}
		};

		// Internal: used to track lightest solution
		struct optimum_t
		{
			// Net burden of the lightest solution
			real_t  net_burden = std::numeric_limits<real_t>::infinity();

			// Choice for last decision in the lightest solution
			index_t choice     = ~index_t(0);

			// Update with an alternative, if it is lighter
			void consider(index_t alt_choice, real_t alt_net_burden)
			{
				if (alt_net_burden < net_burden)
				{
					net_burden = alt_net_burden;
					choice = alt_choice;
				}
			}
		};

		// Internal: used to track lightest solution for every combination of subset/score
		struct optimums_t
		{
			score_t                max_net_points;
			std::vector<optimum_t> store;

			void setup(index_t decisions, score_t max_net_points)
			{
				store.clear();
				store.resize(decisions * (max_net_points+1));
				this->max_net_points = max_net_points;
			}

			optimum_t &operator()(index_t i, score_t score)
			{
				assert(score >= 0 && score <= max_net_points);
				return store[i*(max_net_points+1) + score];
			}
		};

	public:
		// Set of decisions to fill in
		std::vector<decision_t> decisions;

		// Metadata generated by the algorithm.
		optimums_t   optimums;
		size_t       _iterations;
		statistics_t _stats_highest;
		statistics_t _stats_lightest;

	private:
		//std::vector<index_t>    _temp;

	public:
		/*
			Add an unavoidable burden.
		*/
		decision_t& add_burden(real_t burden)
		{
			decisions.emplace_back(decision_t());
			decision_t &decision = decisions.back();
			decision.options.push_back(option_t{burden,0});
			return decision;
		}

		/*
			Add an fixed incentive (modifies the total value of any solution)
		*/
		decision_t& add_incentive(real_t value)
		{
			decisions.emplace_back(decision_t());
			decision_t &decision = decisions.back();
			decision.options.push_back(option_t{0,value});
			return decision;
		}

		/*
			Add a binary decision which has no burden 
		*/
		decision_t& add_binary_item(real_t burden, real_t value)
		{
			decisions.emplace_back(decision_t());
			decision_t &decision = decisions.back();
			decision.options.push_back(option_t{0,0});
			decision.options.push_back(option_t{burden,value});
			return decision;
		}

		/*
			Add an option from an array.
		*/
		template<size_t N>
		decision_t& add_decision(const option_t (&options)[N])
		{
			decisions.emplace_back(decision_t());
			decision_t &decision = decisions.back();
			for (const option_t &option : options) decision.options.push_back(option);
			return decision;
		}

		/*
			Evaluate all decisions, selecting exactly one option for each and overwriting
				the 'option' field to that option's index.

			capacity -- sets a limit on the total burden of selected options.
				If all solutions exceed this limit, the lowest-burden solution is chosen.

			precision -- governs the algorithm's optimality and efficiency.
				The solution's net value will be at least (100 - 100/precision)% of optimal.
				Runtime increases linearly with precision.
		*/
		statistics_t decide(real_t capacity, size_t precision = 50)
		{
			precision = std::max<size_t>(precision, 4);

			_iterations = 0;

			// Prepare algorithm (performs value->points scaling)
			_prepare(precision);

			// Shortcut: if the lightest solution is overburdened, return it (failure)
			if (_stats_lightest.net_burden > capacity)
			{
				return _stats_lightest;
			}

			// Shortcut: if the highest-valued solution is not overburdened, return it
			if (_stats_highest.net_burden <= capacity)
			{
				// Load the choice as noted in _prepare, and return it.
				for (decision_t &decision : decisions) decision.choice = decision._choice_high;
				return _stats_highest;
			}

			// Compute the table of optimums...
			_compute_optimums();

			// Identify the highest-scoring solution that is not over-burden
			index_t last = decisions.size()-1;
			score_t top_score = _stats_highest.net_points;
			while (top_score > 0)
			{
				optimum_t &optimum = optimums(last, top_score);
				if (optimum.net_burden < capacity)
				{
					// Commit this solution
					score_t score = top_score;
					for (index_t i = decisions.size(); i-- > 0;)
					{
						decision_t &decision = decisions[i];
						optimum_t  &optimum = optimums(i, score);

						assert(optimum.choice <= decision.options.size());
						decision.choice = optimum.choice;
						score -= decision.options[optimum.choice]._points;
					}

					break;
				}
				--top_score;
			}

			// Calculate final stats and return.
			statistics_t final_stats;
			for (decision_t &decision : decisions)
				final_stats += decision.options[decision.choice];
			return final_stats;
		}

	private:

		/*
			Main algorithm:
				* Find lightest solution per score for every subset 0..i
		*/
		void _compute_optimums()
		{
			// Initialize optimum grid.
			optimums.setup(decisions.size(), optimums.max_net_points);

			for (index_t i = 0; i < decisions.size(); ++i)
			{
				decision_t &decision = decisions[i];

				for (index_t j = 0, e = decision.options.size(); j < e; ++j)
				{
					// Only consider options with non-negative value.
					option_t &option = decision.options[j];
					if (option._points < 0) continue;

					if (i == 0)
					{
						real_t net_burden = option.burden;
						score_t net_points = option._points;

						optimums(0, net_points).consider(j, net_burden);

						if (EnableProfiling) ++_iterations;
					}
					else
						for (index_t k = 0; k < optimums.max_net_points - option._points; ++k) // TODO fewer iterations?
					{
						real_t net_burden = option.burden + optimums(i-1, k).net_burden;
						score_t net_points = option._points + k;

						optimums(i, net_points).consider(j, net_burden);

						if (EnableProfiling) ++_iterations;
					}
				}
			}
		}

		// Prepare algorithm
		void _prepare(size_t precision)
		{
			real_t max_value_range = 0;

			_stats_lightest = statistics_t();
			_stats_highest = statistics_t();

			/*
				First-pass:
					* ascertain lightest item(s) and pick them by default
					* ascertain maximum range of relevant values
			*/
			for (decision_t &decision : decisions) if (decision.options.size())
			{
				// Look for the range of values
				const option_t &first = decision.options[0];
				real_t light_burden = first.burden, light_value = first.value, max_value = first.value;
				decision.choice = 0;
				for (size_t i = 1, e = decision.options.size(); i < e; ++i)
				{
					const option_t &option = decision.options[i];
					if (option.value  > max_value)
					{
						max_value = option.value;
					}
					if (option.burden < light_burden)
					{
						light_burden = option.burden;
						light_value  = option.value;
						decision.choice = i;
					}
				}
				decision._choice_min = decision.choice;
				decision._value_min = light_value;

				_stats_lightest.net_burden += light_burden;
				_stats_lightest.net_value  += light_value;

				max_value_range = std::max(max_value_range, max_value - light_value);
			}

			/*
				Second pass:
					* score all relevant options from [1..precision].
					* calculate the highest-valued solution as a reference.
			*/
			const real_t value_to_points_scale = precision / max_value_range;
			for (decision_t &decision : decisions)
			{
				const option_t &first = decision.options[0];

				// Searching for the highest-value option.
				option_t high_option  = first;
				decision._choice_high = 0;

				for (size_t i = 0, e = decision.options.size(); i < e; ++i)
				{
					option_t &option = decision.options[i];

					// Calculate quantized value ("points").
					option._points = score_t(std::ceil((option.value - decision._value_min) * value_to_points_scale));

					// Select most valuable item
					if (option._points > high_option._points)
					{
						high_option  = option;
						decision._choice_high = i;
					}
				}

				// Add lightest option to lightest total.
				_stats_highest += high_option;
			}

#if 0
			// DEBUG
			std::cout << "  value_to_points_scale = " << value_to_points_scale << std::endl;
			for (decision_t &decision : decisions)
			{
				std::cout << "  marginal scores:";
				for (option_t &option : decision.options)
					std::cout << " $" << (option.value - decision._value_min) << "->@" << option._points;
				std::cout << std::endl;
			}
#endif

			optimums.setup(0, _stats_highest.net_points);
		}
	};

	/*
		Solutions are typically 90% - 99.9% optimal, so float precision is usually more than enough.
	*/
	using Problem = Problem_<float>;
}
